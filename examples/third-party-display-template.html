<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metro-PIDS 第三方显示器模板</title>
    <!-- 
        注意：此模板展示了基本的消息接收和显示功能。
        如需使用站点计算 API（支持短交路、暂缓站、大站车、直达车等），
        请参考 examples/display-with-station-calculator.html 示例文件。
        
        站点计算 API 文档：请参考 API_DOCUMENTATION.md 中的"站点计算 API"章节。
    -->
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: #090d12;
            color: #e2e8f0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        .display-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .line-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .line-name {
            font-size: 32px;
            font-weight: bold;
            color: #60a5fa;
        }

        .line-number {
            font-size: 18px;
            color: #94a3b8;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(16, 185, 129, 0.2);
            border-radius: 20px;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s ease-in-out infinite;
        }

        .status-dot.offline {
            background: #64748b;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }


        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            overflow: hidden;
        }

        .panel {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 10px;
            padding: 25px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-height: 0; /* 允许 flex 子元素收缩 */
            overflow: hidden; /* 防止内容溢出 */
        }

        .panel-title {
            font-size: 18px;
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            padding-bottom: 10px;
        }

        .current-station {
            font-size: 48px;
            font-weight: bold;
            color: #60a5fa;
            text-align: center;
            padding: 20px;
            background: rgba(96, 165, 250, 0.1);
            border-radius: 8px;
        }

        .station-status {
            text-align: center;
            margin: 10px 0;
        }

        .status-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .status-badge.arrived {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-badge.departed {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .station-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 6px;
        }

        .info-label {
            color: #94a3b8;
            font-size: 14px;
        }

        .info-value {
            color: #e2e8f0;
            font-size: 16px;
            font-weight: 500;
        }

        .stations-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-right: 10px;
        }

        .station-item {
            padding: 12px 15px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 6px;
            border-left: 3px solid transparent;
            transition: all 0.3s;
        }

        .station-item.current {
            background: rgba(96, 165, 250, 0.2);
            border-left-color: #60a5fa;
            font-weight: bold;
        }

        .station-item.passed {
            opacity: 0.5;
        }

        .station-name {
            font-size: 16px;
            color: #e2e8f0;
        }

        .station-en {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 4px;
        }

        .debug-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            padding: 15px;
            max-width: 400px;
            font-size: 12px;
            color: #94a3b8;
            display: none;
        }

        .debug-panel.show {
            display: block;
        }

        .debug-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #e2e8f0;
        }

        .debug-item {
            margin: 4px 0;
            word-break: break-all;
        }

        /* 滚动条样式 */
        .stations-list::-webkit-scrollbar {
            width: 6px;
        }

        .stations-list::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 3px;
        }

        .stations-list::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.3);
            border-radius: 3px;
        }

        .stations-list::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.5);
        }

        /* 响应式布局 */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="display-container">
        <!-- 头部信息 -->
        <div class="header">
            <div class="line-info">
                <div class="line-name" id="lineName">等待数据...</div>
                <div class="line-number" id="lineNumber">线路号: --</div>
            </div>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">已连接</span>
            </div>
        </div>


        <!-- 主要内容 -->
        <div class="main-content">
            <!-- 左侧：当前站点信息 -->
            <div class="panel">
                <div class="panel-title">当前站点</div>
                <div class="current-station" id="currentStation">--</div>
                <div class="station-status" id="stationStatus">
                    <span class="status-badge" id="statusBadge">--</span>
                </div>
                <div class="station-info">
                    <div class="info-item">
                        <span class="info-label">站点索引</span>
                        <span class="info-value" id="stationIndex">-- / --</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">方向</span>
                        <span class="info-value" id="direction">--</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">车次</span>
                        <span class="info-value" id="trainNumber">--</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">当前时间</span>
                        <span class="info-value" id="currentTime">--</span>
                    </div>
                </div>
            </div>

            <!-- 右侧：站点列表 -->
            <div class="panel">
                <div class="panel-title">站点列表</div>
                <div class="stations-list" id="stationsList">
                    <div style="text-align: center; color: #94a3b8; padding: 20px;">
                        等待数据加载...
                    </div>
                </div>
            </div>
        </div>

        <!-- 调试面板（按 F12 显示/隐藏） -->
        <div class="debug-panel" id="debugPanel">
            <div class="debug-title">调试信息</div>
            <div class="debug-item" id="debugInfo">等待消息...</div>
        </div>
    </div>

    <script>
        // ==================== 配置 ====================
        const CONFIG = {
            channelName: 'metro_pids_v3',  // BroadcastChannel 频道名称
            snapshotKey: 'metro_pids_display_snapshot',  // localStorage 快照键名
            enableDebug: false,  // 是否启用调试面板（按 F12 切换）
            wsEnabled: true,      // 是否启用 WebSocket（跨设备 / 局域网）
            wsUrl: '',            // 可留空自动根据当前 host 拼 URL
            wsPort: 9400,
            wsRetryMs: 1500,
        };

        // ==================== 站点计算 API 配置 ====================
        // 注意：如果您的第三方显示器与 Metro-PIDS 主程序在同一项目中，
        // 可以使用 ES6 模块导入站点计算 API：
        // 
        // import {
        //   getFilteredStations,
        //   calculateDisplayStationInfo,
        //   isSkippedByService,
        //   getNextValidSt,
        //   calculateNextStationIndex
        // } from '../src/utils/displayStationCalculator.js';
        //
        // 显示器配置示例：
        // const displayConfig = {
        //   filterByDirection: true,  // 是否根据方向过滤站点（dock限制）
        //   reverseOnDown: true       // 下行方向时是否反转站点顺序
        // };
        //
        // 使用示例：
        // const stationInfo = calculateDisplayStationInfo(appData, rtState, displayConfig);
        // const filteredStations = getFilteredStations(appData, appData.meta?.dirType, displayConfig);
        //
        // 更多信息请参考 API_DOCUMENTATION.md 中的"站点计算 API"章节

        // ==================== 状态管理 ====================
        let appData = null;
        let rtState = { idx: 0, state: 0 };
        let bc = null;
        let bcConnected = false;
        let ws = null;
        let wsConnected = false;
        let wsRetryTimer = null;
<<<<<<< Updated upstream
=======
        let wsPingTimer = null;
>>>>>>> Stashed changes
        let isConnected = false;

        function getClientVersion() {
            try {
                const fromQuery = new URLSearchParams(window.location.search).get('clientVersion');
                if (fromQuery && String(fromQuery).trim()) return String(fromQuery).trim();
            } catch (e) {}
            try {
                const fromWindow = window.METRO_PIDS_CLIENT_VERSION || window.__APP_VERSION__ || window.__APP_VERSION;
                if (fromWindow && String(fromWindow).trim()) return String(fromWindow).trim();
            } catch (e) {}
            try {
                const fromStorage = localStorage.getItem('metro_pids_client_version');
                if (fromStorage && fromStorage.trim()) return fromStorage.trim();
            } catch (e) {}
            return 'web-client';
        }
        const CLIENT_ID_KEY = 'metro_pids_ws_client_id';

        function getOrCreateClientId() {
            try {
                const existed = localStorage.getItem(CLIENT_ID_KEY);
                if (existed && existed.trim()) return existed.trim();
            } catch (e) {}
            const generated = (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function')
                ? crypto.randomUUID()
                : `client-${Date.now()}-${Math.random().toString(16).slice(2, 10)}`;
            try { localStorage.setItem(CLIENT_ID_KEY, generated); } catch (e) {}
            return generated;
        }

        function getClientDisplayId() {
            try {
                const id = new URLSearchParams(window.location.search).get('displayId');
                return id ? String(id).trim() : '';
            } catch (e) {
                return '';
            }
        }

        function getClientSystem() {
            try {
                if (navigator.userAgentData && navigator.userAgentData.platform) {
                    return String(navigator.userAgentData.platform);
                }
                if (navigator.platform) return String(navigator.platform);
                if (navigator.userAgent) return String(navigator.userAgent);
            } catch (e) {}
            return 'unknown';
        }

        function getClientHelloPayload() {
            return {
                t: 'HELLO',
                clientId: getOrCreateClientId(),
                displayId: getClientDisplayId(),
                clientVersion: getClientVersion(),
                system: getClientSystem(),
                meta: {
                    clientId: getOrCreateClientId(),
                    displayId: getClientDisplayId(),
                    clientVersion: getClientVersion(),
                    system: getClientSystem()
                }
            };
        }

        function startWsPing() {
            if (wsPingTimer) return;
            wsPingTimer = setInterval(() => {
                if (!ws || ws.readyState !== WebSocket.OPEN) return;
                try {
                    ws.send(JSON.stringify({
                        t: 'PING',
                        ts: Date.now(),
                        displayId: getClientDisplayId(),
                        clientVersion: getClientVersion(),
                        system: getClientSystem()
                    }));
                } catch (e) {}
            }, 3000);
        }

        function stopWsPing() {
            if (!wsPingTimer) return;
            clearInterval(wsPingTimer);
            wsPingTimer = null;
        }

        // ==================== BroadcastChannel 初始化 ====================
        function initBroadcastChannel() {
            if (typeof BroadcastChannel !== 'undefined') {
                try {
                    bc = new BroadcastChannel(CONFIG.channelName);
                    console.log('[Display] BroadcastChannel 已创建:', CONFIG.channelName);
                    
                    bc.addEventListener('message', (event) => {
                        handleMessage(event.data);
                    });
                    
                    // 显示端启动时，请求主程序同步数据
                    bc.postMessage({ t: 'REQ' });
                    bcConnected = true;
                    updateConnectionStatus(wsConnected || bcConnected);
                } catch (e) {
                    console.warn('[Display] BroadcastChannel 创建失败:', e);
                    bcConnected = false;
                    updateConnectionStatus(wsConnected || bcConnected);
                }
            } else {
                console.warn('[Display] 浏览器不支持 BroadcastChannel');
                bcConnected = false;
                updateConnectionStatus(wsConnected || bcConnected);
            }
        }

        // ==================== WebSocket 初始化（用于跨设备 / 局域网） ====================
        function getWsUrl() {
            if (CONFIG.wsUrl && CONFIG.wsUrl.trim()) return CONFIG.wsUrl.trim();
            if (typeof window === 'undefined') return null;
            const host = window.location.hostname || 'localhost';
            const port = CONFIG.wsPort || 9400;
            const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            return `${proto}//${host}:${port}`;
        }

        function scheduleWsReconnect() {
            if (!CONFIG.wsEnabled) return;
            if (wsRetryTimer) return;
            wsRetryTimer = setTimeout(() => {
                wsRetryTimer = null;
                connectWebSocket();
            }, CONFIG.wsRetryMs || 1500);
        }

        function connectWebSocket() {
            if (!CONFIG.wsEnabled) return;
            const url = getWsUrl();
            if (!url) {
                console.warn('[Display] 未能解析 WebSocket URL');
                return;
            }
            try {
                if (ws) {
                    ws.close();
                    ws = null;
                }
            } catch (e) {}

            try {
                ws = new WebSocket(url);
            } catch (e) {
                console.warn('[Display] WebSocket 创建失败:', e);
                wsConnected = false;
                updateConnectionStatus(wsConnected || bcConnected);
                scheduleWsReconnect();
                return;
            }

            wsConnected = false;

            ws.addEventListener('open', () => {
                wsConnected = true;
                updateConnectionStatus(wsConnected || bcConnected);
<<<<<<< Updated upstream
                try { ws.send(JSON.stringify({ t: 'REQ' })); } catch (e) {}
=======
                try { ws.send(JSON.stringify(getClientHelloPayload())); } catch (e) {}
                try { ws.send(JSON.stringify({ t: 'REQ' })); } catch (e) {}
                startWsPing();
>>>>>>> Stashed changes
            });

            ws.addEventListener('message', (event) => {
                if (!event) return;
                const payload = event.data;
                try {
                    const parsed = typeof payload === 'string' ? JSON.parse(payload) : payload;
                    handleMessage(parsed);
                } catch (e) {
                    handleMessage(event);
                }
            });

            ws.addEventListener('close', () => {
                wsConnected = false;
                updateConnectionStatus(wsConnected || bcConnected);
<<<<<<< Updated upstream
=======
                stopWsPing();
>>>>>>> Stashed changes
                scheduleWsReconnect();
            });

            ws.addEventListener('error', () => {
                wsConnected = false;
                updateConnectionStatus(wsConnected || bcConnected);
<<<<<<< Updated upstream
=======
                stopWsPing();
>>>>>>> Stashed changes
                scheduleWsReconnect();
            });
        }

        function sendViaWebSocket(payload) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return false;
            try {
                ws.send(JSON.stringify(payload));
                return true;
            } catch (e) {
                console.warn('[Display] WebSocket 发送失败:', e);
                return false;
            }
        }

        // ==================== 回退方案：window.postMessage ====================
        // 重要：window.postMessage 是必需的，因为主程序通过 executeJavaScript 发送消息时
        // 会同时使用 BroadcastChannel 和 window.postMessage，确保 file:// 协议也能收到消息
        if (typeof window !== 'undefined') {
            window.addEventListener('message', (event) => {
                // 处理所有包含 t 字段的消息（不检查 origin，因为主程序通过 executeJavaScript 发送）
                if (event.data && event.data.t) {
                    console.log('[Display] 通过 window.postMessage 收到消息:', event.data.t);
                    handleMessage(event.data);
                }
            });
        }

        // ==================== 消息处理 ====================
        function handleMessage(data) {
            if (!data || !data.t) return;
            
            console.log('[Display] 收到消息:', data.t, data.d ? '有数据' : '无数据');
            updateDebugInfo(`收到消息类型: ${data.t}`);
            
            switch (data.t) {
                case 'SYNC':
                    // 同步数据消息
                    appData = data.d;
                    rtState = data.r || rtState;
                    
                    console.log('[Display] 同步数据:', {
                        hasAppData: !!appData,
                        hasStations: !!(appData && appData.stations),
                        stationsCount: appData && appData.stations ? appData.stations.length : 0,
                        currentIdx: rtState?.idx ?? 0
                    });
                    
                    // 保存快照到 localStorage
                    saveSnapshot(data);
                    
                    // 更新显示
                    updateDisplay();
                    updateConnectionStatus(true);
                    break;
                    
                case 'CMD_KEY':
                    // 控制命令消息
                    updateDebugInfo(`收到控制命令: ${data.code}`);
                    handleControlCommand(data.code);
                    break;
                    
                case 'REC_START':
                    // 开始录制
                    updateDebugInfo(`开始录制，比特率: ${data.bps}`);
                    break;
                    
                case 'REC_STOP':
                    // 停止录制
                    updateDebugInfo('停止录制');
                    break;
                    
                case 'REQ':
                    // 请求数据（主程序发送，通常不需要处理）
                    break;
            }
        }

        // ==================== 控制命令处理 ====================
        function handleControlCommand(keyCode) {
            // 根据按键代码执行相应操作
            switch (keyCode) {
                case 'ArrowRight':
                    console.log('[Display] 下一站');
                    break;
                case 'ArrowLeft':
                    console.log('[Display] 上一站');
                    break;
                case 'Enter':
                    console.log('[Display] 到达');
                    break;
                case 'Space':
                    console.log('[Display] 发车');
                    break;
                default:
                    console.log('[Display] 未知按键:', keyCode);
            }
        }

        // ==================== 更新显示 ====================
        function updateDisplay() {
            if (!appData) {
                console.warn('[Display] updateDisplay: appData 为空');
                return;
            }
            
            console.log('[Display] 更新显示，站点数量:', appData.stations ? appData.stations.length : 0);
            
            // 更新线路信息
            const lineName = appData.meta?.lineName || appData.lineName || '未知线路';
            const lineNumber = appData.meta?.lineNumber || appData.lineNumber || '--';
            document.getElementById('lineName').textContent = lineName;
            document.getElementById('lineNumber').textContent = `线路号: ${lineNumber}`;
            
            // 更新当前站点
            // 注意：这里使用原始索引，如果需要使用站点计算 API 进行过滤和计算，
            // 请参考以下示例代码（需要导入 displayStationCalculator.js）：
            //
            // const displayConfig = {
            //   filterByDirection: true,
            //   reverseOnDown: false  // 根据您的需求设置
            // };
            // const stationInfo = calculateDisplayStationInfo(appData, rtState, displayConfig);
            // const filteredStations = getFilteredStations(appData, appData.meta?.dirType, displayConfig);
            // const currentStation = filteredStations[stationInfo.currentIdx];
            // const nextStation = stationInfo.nextIdx >= 0 ? filteredStations[stationInfo.nextIdx] : null;
            //
            // 使用过滤后的站点和索引：
            // - currentStation: 当前站（过滤后数组中的站点）
            // - nextStation: 下一站（过滤后数组中的站点，仅在出站状态时）
            // - stationInfo.currentIdx: 当前站在过滤后数组中的索引
            // - stationInfo.nextIdx: 下一站在过滤后数组中的索引
            // - stationInfo.nextStationName: 下一站名称
            
            const currentIdx = rtState?.idx ?? 0;
            const stations = appData.stations || [];
            const currentStation = stations[currentIdx];
            
            if (currentStation) {
                document.getElementById('currentStation').textContent = currentStation.name || '--';
                document.getElementById('stationIndex').textContent = `${currentIdx} / ${Math.max(0, stations.length - 1)}`;
            } else {
                document.getElementById('currentStation').textContent = '--';
                document.getElementById('stationIndex').textContent = '-- / --';
            }
            
            // 更新到站/出站状态
            const currentState = rtState?.state ?? 0; // 0: 到站, 1: 出站
            const statusBadge = document.getElementById('statusBadge');
            if (statusBadge) {
                if (currentState === 0) {
                    statusBadge.textContent = '到站';
                    statusBadge.className = 'status-badge arrived';
                } else {
                    statusBadge.textContent = '出站';
                    statusBadge.className = 'status-badge departed';
                }
            }
            
            // 更新其他信息
            document.getElementById('direction').textContent = appData.direction || appData.meta?.dirType || '--';
            document.getElementById('trainNumber').textContent = appData.trainNumber || '--';
            updateCurrentTime();
            
            // 更新站点列表
            // 注意：如果需要显示过滤后的站点列表（例如，仅显示当前方向停靠的站点），
            // 请使用 getFilteredStations API：
            //
            // const filteredStations = getFilteredStations(
            //   appData,
            //   appData.meta?.dirType,
            //   { filterByDirection: true, reverseOnDown: false }
            // );
            // updateStationsList(filteredStations, stationInfo.currentIdx);
            //
            updateStationsList(stations, currentIdx);
        }

        // ==================== 更新站点列表 ====================
        function updateStationsList(stations, currentIdx) {
            const listElement = document.getElementById('stationsList');
            
            if (!stations || stations.length === 0) {
                listElement.innerHTML = '<div style="text-align: center; color: #94a3b8; padding: 20px;">暂无站点数据</div>';
                return;
            }
            
            listElement.innerHTML = stations.map((station, index) => {
                const isCurrent = index === currentIdx;
                const isPassed = index < currentIdx;
                
                return `
                    <div class="station-item ${isCurrent ? 'current' : ''} ${isPassed ? 'passed' : ''}">
                        <div class="station-name">${station.name || '未知站点'}</div>
                        ${station.en ? `<div class="station-en">${station.en}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // ==================== 更新当前时间 ====================
        function updateCurrentTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('zh-CN', { 
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('currentTime').textContent = timeString;
        }

        // ==================== 更新连接状态 ====================
        function updateConnectionStatus(connected) {
            isConnected = connected;
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusDot.classList.remove('offline');
                statusText.textContent = '已连接';
            } else {
                statusDot.classList.add('offline');
                statusText.textContent = '未连接';
            }
        }

        // ==================== 保存快照 ====================
        function saveSnapshot(data) {
            if (typeof window === 'undefined' || !window.localStorage) return;
            
            try {
                window.localStorage.setItem(CONFIG.snapshotKey, JSON.stringify(data));
            } catch (e) {
                console.warn('[Display] 保存快照失败:', e);
            }
        }

        // ==================== 恢复快照 ====================
        function restoreSnapshot() {
            if (typeof window === 'undefined' || !window.localStorage) return false;
            
            const raw = window.localStorage.getItem(CONFIG.snapshotKey);
            if (!raw) return false;
            
            try {
                const data = JSON.parse(raw);
                if (data && data.t === 'SYNC') {
                    appData = data.d;
                    rtState = data.r || rtState;
                    updateDisplay();
                    updateDebugInfo('已恢复数据快照');
                    return true;
                }
            } catch (err) {
                console.warn('[Display] 恢复快照失败:', err);
            }
            
            return false;
        }

        // ==================== 调试面板 ====================
        function updateDebugInfo(message) {
            if (!CONFIG.enableDebug) return;
            
            const debugPanel = document.getElementById('debugPanel');
            const debugInfo = document.getElementById('debugInfo');
            
            const timestamp = new Date().toLocaleTimeString();
            debugInfo.textContent = `[${timestamp}] ${message}`;
        }

        // ==================== 通过广播发送控制命令（可靠方案，不依赖HTTP API） ====================
        function sendCommand(command) {
            // 直接发送命令格式，让主程序根据用户配置的快捷键来判断是否执行
            // 通过 BroadcastChannel 发送 CMD_KEY 消息到主程序
            const payload = { t: 'CMD_KEY', command: command };

            if (sendViaWebSocket(payload)) {
                console.log('[Display] ✅ 控制命令已通过 WebSocket 发送:', command);
                return true;
            }

            if (bc) {
                try {
                    bc.postMessage(payload);
                    console.log('[Display] ✅ 控制命令已通过广播发送:', command);
                    return true;
                } catch (e) {
                    console.warn('[Display] ❌ 广播发送命令失败:', e);
                    return false;
                }
            }

            console.warn('[Display] ❌ 无可用通道发送控制命令');
            return false;
        }

        // ==================== 通过广播请求数据同步 ====================
        function requestDataSync() {
            // 通过 BroadcastChannel 发送 REQ 消息，请求主程序同步数据
            const payload = { t: 'REQ' };

            if (sendViaWebSocket(payload)) {
                console.log('[Display] ✅ 已通过 WebSocket 请求数据同步');
                return true;
            }

            if (bc) {
                try {
                    bc.postMessage(payload);
                    console.log('[Display] ✅ 已通过广播请求数据同步');
                    return true;
                } catch (e) {
                    console.warn('[Display] ❌ 广播请求数据失败:', e);
                    return false;
                }
            }
            console.warn('[Display] ❌ 无可用通道请求数据');
            return false;
        }

        // ==================== 键盘快捷键（支持自定义快捷键） ====================
        // 如果使用 SDK，可以使用 installKeyboardHandler 自动处理键盘事件
        // 主程序会根据用户配置的快捷键自动匹配并执行对应操作
        let keyboardUninstall = null;
        if (typeof createDisplaySdk !== 'undefined') {
            try {
                const sdk = createDisplaySdk({ channelName: CONFIG.channelName });
                if (sdk && typeof sdk.installKeyboardHandler === 'function') {
                    keyboardUninstall = sdk.installKeyboardHandler();
                    console.log('[Display] ✅ 键盘事件处理器已安装（支持自定义快捷键）');
                }
            } catch (e) {
                console.warn('[Display] ⚠️ 无法安装键盘事件处理器:', e);
            }
        }

        // F12 切换调试面板（保留此功能）
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F12') {
                e.preventDefault();
                CONFIG.enableDebug = !CONFIG.enableDebug;
                const debugPanel = document.getElementById('debugPanel');
                if (CONFIG.enableDebug) {
                    debugPanel.classList.add('show');
                } else {
                    debugPanel.classList.remove('show');
                }
                return;
            }
            // 其他按键由 installKeyboardHandler 处理
        });

        // ==================== 确保窗口可接收键盘事件 ====================
        function ensureFocus() {
            try {
                if (document && document.body) {
                    document.body.setAttribute('tabindex', '-1');
                    document.body.focus();
                }
                // 再尝试聚焦窗口本身
                if (typeof window !== 'undefined' && window.focus) {
                    window.focus();
                }
                console.log('[Display] 已尝试聚焦窗口以接收键盘事件');
            } catch (e) {
                console.warn('[Display] 聚焦窗口失败:', e);
            }
        }

        // ==================== 初始化 ====================
        function init() {
            console.log('[Display] 第三方显示器模板初始化');
            
            // 初始化 WebSocket（跨设备）
            connectWebSocket();

            // 初始化 BroadcastChannel
            initBroadcastChannel();
            
            // 尝试恢复快照
            restoreSnapshot();
            
            // 通过广播请求初始数据（不依赖API服务器）
            requestDataSync();

            // 启动时钟更新
            setInterval(updateCurrentTime, 1000);
            updateCurrentTime();

            // 确保能接收键盘事件
            ensureFocus();
            // 用户点击任意位置时也再次聚焦，避免丢焦
            document.addEventListener('click', ensureFocus, { once: true });
            
            // 如果 3 秒后仍未连接，显示警告
            setTimeout(() => {
                if (!isConnected) {
                    console.warn('[Display] 警告：未收到主程序的数据同步');
                    updateDebugInfo('警告：未收到主程序的数据同步');
                }
            }, 3000);
        }

        // ==================== 页面加载完成后初始化 ====================
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // ==================== 页面卸载时清理 ====================
        window.addEventListener('beforeunload', () => {
            if (bc) {
                bc.close();
            }
            if (ws) {
                try { ws.close(); } catch (e) {}
            }
            if (wsRetryTimer) {
                clearTimeout(wsRetryTimer);
            }
        });
    </script>
</body>
</html>
